import os
from matplotlib import pyplot
from numpy import arange
import bisect
from decimal import *
import numpy
import math
from scipy import stats as scistats
import csv
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
from scipy.ndimage.filters import correlate as convolveim
import copy
from HuffmanCoding_weights import HuffmanCoding
from bitstring import Bits

def bindigits(n, bits):
    s = bin(n & int("1"*bits, 2))[2:]
    return ("{0:0>%s}" % (bits)).format(s)

numpy.random.seed(9001)

num_pe = 8
ic = 8 
ic_total = 8 
oc = 64 
oc_total = 64
stride = 2
kernel_size = 7 
output_kernel_size = 3
ia_size = 230 
oa_size = (ia_size - kernel_size + 1)/(stride) + output_kernel_size - 1
write_ia_num = 0
write_oa_num = 1
rram_banks = 8 
right_shift = 0 
ia_ram_banks = 4
pe_ic = 8
pe_oc = 8

#random filters
#weights = numpy.random.randint(-128, high=127, size=(oc, ic, kernel_size, kernel_size)) 
#w = numpy.random.randint(-8, high=16, size=(oc_total, ic_total, kernel_size, kernel_size)) 
#sparse_loc = (numpy.random.randint(-3, high=4, size=(oc_total, ic_total, kernel_size, kernel_size))).clip(min=0)
#sparse_w = numpy.multiply(w, sparse_loc)
sparse_w = numpy.zeros((oc_total, ic_total, kernel_size, kernel_size), dtype=numpy.int) 

row_cnt = 0
col_cnt = 0
ic_cnt = 0
oc_cnt = 0
with open("1_conv_weight.txt") as weight_file:
    for line in weight_file:
        split_line = line.split(",")
        single_weight = Bits(bin=(''.join(map(str, split_line))))
        #print(single_weight.int)
        sparse_w[oc_cnt][ic_cnt][row_cnt][col_cnt] = single_weight.int
        row_cnt = row_cnt + 1
        if(row_cnt == kernel_size):
            row_cnt = 0
            col_cnt = col_cnt + 1
        if(col_cnt == kernel_size):
            col_cnt = 0
            ic_cnt = ic_cnt + 1
        if(ic_cnt == 4 ):
            ic_cnt = 0
            oc_cnt = oc_cnt + 1
        if(oc_cnt == oc_total):
            oc_cnt = 0


#for oc_cnt in range (0, oc):
#    for ic_cnt in range (0, ic):
#        for row in range (0, kernel_size):
#            for col in range (0, kernel_size):
#                if(row != (kernel_size-1)/2 or col != (kernel_size-1)/2):
#                    sparse_w[oc_cnt][ic_cnt][row][col] = 0

print("density: " + str(float(numpy.count_nonzero(sparse_w))/float(ic_total*oc_total*kernel_size*kernel_size)))

#randn(oc, ic, kernel_size, kernel_size)
#weights = weights.astype(int)
#random ias 
#ia = numpy.random.randint(-16, high=16, size=(ic_total, ia_size, ia_size))
ia = numpy.zeros((ic_total, ia_size, ia_size), dtype=numpy.int)

row_cnt = 0
col_cnt = 0
ic_cnt = 0
oc_cnt = 0
with open("1_input.txt") as ia_file:
    for line in ia_file:
        split_line = line.split(",")
        single_ia = Bits(bin=(''.join(map(str, split_line))))
        #print(single_ia.int)
        ia[ic_cnt][row_cnt + (kernel_size-1)/2][col_cnt + (kernel_size-1)/2] = single_ia.int
        row_cnt = row_cnt + 1
        if(row_cnt == ia_size - kernel_size + 1):
            row_cnt = 0
            col_cnt = col_cnt + 1
        if(col_cnt == ia_size - kernel_size + 1):
            col_cnt = 0
            ic_cnt = ic_cnt + 1
        if(ic_cnt == ic_total):
            ic_cnt = 0

for ic_cnt in range (0, ic_total):
    for row in range (0, ia_size):
        for col in range (0, ia_size):
            if(row < (kernel_size-1)/2 or col < (kernel_size-1)/2 or row >= ia_size - (kernel_size-1)/2 or col >= ia_size - (kernel_size-1)/2):
                ia[ic_cnt][row][col] = 0 

#ia = numpy.random.randint(-128, high=127, size=(ic, ia_size, ia_size))
#randn(ic, ia_size, ia_size)
#ia = ia.astype(int)

oa_read= numpy.zeros((oc_total, oa_size-output_kernel_size+1, oa_size-output_kernel_size+1), dtype=numpy.int)

row_cnt = 0
col_cnt = 0
ic_cnt = 0
oc_cnt = 0
with open("1_conv_output.txt") as oa_file:
    for line in oa_file:
        split_line = line.split(",")
        single_oa = Bits(bin=(''.join(map(str, split_line))))
        oa_read[oc_cnt][row_cnt][col_cnt] = single_oa.int
        row_cnt = row_cnt + 1
        if(row_cnt == oa_size - output_kernel_size + 1):
            row_cnt = 0
            col_cnt = col_cnt + 1
        if(col_cnt == oa_size - output_kernel_size + 1):
            col_cnt = 0
            oc_cnt = oc_cnt + 1
        if(oc_cnt == oc_total):
            oc_cnt = 0

oa_raw = numpy.zeros((oc_total, ia_size, ia_size), dtype=numpy.int) 
for oc_cnt in range (0, oc_total):
    for ic_cnt in range (0, ic_total):
        oa_raw[oc_cnt] = numpy.add(oa_raw[oc_cnt], convolveim(ia[ic_cnt], sparse_w[oc_cnt][ic_cnt], mode='constant'))

oa = numpy.zeros((oc_total, oa_size, oa_size), dtype=numpy.int) 
for oc_cnt in range (0, oc_total):
    for row in range (0, oa_size-output_kernel_size+1):
        for col in range (0, oa_size-output_kernel_size+1):
            oa[oc_cnt][row+(output_kernel_size-1)/2][col+(output_kernel_size-1)/2] = oa_raw[oc_cnt][stride*row+(kernel_size-1)/2][stride*col+(kernel_size-1)/2]

oa_original = copy.deepcopy(oa)
oa = numpy.right_shift(oa, right_shift)

#print('\n')

weight_list = []
runlength_list = []
abs_loc_list = [] 

RRAM_full_file = []
for i in range(0, num_pe):
    RRAM_full_file.append(open('pe_' + str(i) + '_RRAM_full_' + str(i) + '.mem','w+'))

RRAM_file = []
for i in range(0, num_pe):
    RRAM_file.append(open('pe_' + str(i) + '_RRAM_' + str(i) + '.mem','w+'))


#RRAM
rram_mem = []
rram_cnt = []
for j in range(0, num_pe):
    rram_mem.append([])
    rram_cnt.append([])
    for i in range(0, rram_banks):
        rram_mem[j].append(open('pe_' + str(j) + '_rram_' + str(i) + '.mem','w+'))
        rram_cnt[j].append(0)

for pe_id in range(0, num_pe):
    weight_list.append([])
    runlength_list.append([])
    abs_loc_list.append([])

    #8 pe --> 4 ic + 2 oc
    #for oc_cnt_base in range (pe_id/4 * oc/pe_oc, (pe_id/4+1) * oc/pe_oc): 
    #    for ic_cnt_base in range (pe_id%4 * ic/pe_ic, (pe_id%4+1) * ic/pe_ic): 
    for oc_cnt_base in range (0, oc/pe_oc): 
        for ic_cnt_base in range (0 , ic/pe_ic): 
            for row in range (0, kernel_size):
                for col in range (0, kernel_size):
                    runlength = 0
                    for oc_cnt in range (0, pe_oc): 
                        for ic_cnt in range (0, pe_ic): 
                            if(sparse_w[oc_cnt_base*pe_oc+oc_cnt][ic_cnt_base*pe_ic+ic_cnt][row][col] == 0):
                                if(runlength == 32 or (oc_cnt == pe_oc-1 and ic_cnt == pe_ic-1)):
                                    weight_list[pe_id].append(0)
                                    runlength_list[pe_id].append(runlength)
                                    abs_loc_list[pe_id].append([oc_cnt_base, ic_cnt_base, row, col])
                                    runlength = 1
                                else:
                                    runlength = runlength + 1
                            else:
                                weight_list[pe_id].append(sparse_w[oc_cnt_base*pe_oc+oc_cnt][ic_cnt_base*pe_ic+ic_cnt][row][col])
                                runlength_list[pe_id].append(runlength)
                                abs_loc_list[pe_id].append([oc_cnt_base, ic_cnt_base, row, col])
                                runlength = 1
    
    weights_htree = HuffmanCoding(weight_list[pe_id])
    weight_list_coded = weights_htree.compress()
    weight_list_decoded = weights_htree.decompress(weight_list_coded)
    weight_codes = weights_htree.get_codes()
    weight_table = weights_htree.get_code_table()
    runlength_htree = HuffmanCoding(runlength_list[pe_id])
    runlength_list_coded = runlength_htree.compress()
    runlength_list_decoded = runlength_htree.decompress(runlength_list_coded)
    runlength_codes = runlength_htree.get_codes()
    runlength_table= runlength_htree.get_code_table()

    #print (weight_list_decoded == weight_list)
    #print (runlength_list_decoded == runlength_list)
    weight_mapping_file = open('pe_' + str(pe_id) + '_weight_mapping.txt', 'w')
    weight_table_file = open('pe_' + str(pe_id) + '_weight_table.txt', 'w')
    weight_raw_file = open('pe_' + str(pe_id) + '_weight_list_raw.txt', 'w')
    weight_coded_file = open('pe_' + str(pe_id) + '_weight_list_coded.txt', 'w')
    runlength_mapping_file = open('pe_' + str(pe_id) + '_runlength_mapping.txt', 'w')
    runlength_table_file = open('pe_' + str(pe_id) + '_runlength_table.txt', 'w')
    runlength_raw_file = open('pe_' + str(pe_id) + '_runlength_list_raw.txt', 'w')
    runlength_coded_file = open('pe_' + str(pe_id) + '_runlength_list_coded.txt', 'w')
    for item in weight_list[pe_id]:
      weight_raw_file.write("%s\n" % item)
    for item in weight_list_coded:
      weight_coded_file.write("%s\n" % item)
    for item in runlength_list[pe_id]:
      runlength_raw_file.write("%s\n" % item)
    for item in runlength_list_coded:
      runlength_coded_file.write("%s\n" % item)
    for item in weight_codes:
        weight_mapping_file.write(str(item) + ' ' + str(weight_codes[item]) + '\n')
    for subtree in weight_table:
        for item in subtree:
            if(item ==''):
                weight_table_file.write('00000000000000' + '\n')
            else:
                weight_table_file.write(item + '\n')
    for item in runlength_codes:
        runlength_mapping_file.write(str(item) + ' ' + str(runlength_codes[item]) + '\n')
    for subtree in runlength_table:
        for item in subtree:
            if(item ==''):
                runlength_table_file.write('00000000000000' + '\n')
            else:
                runlength_table_file.write(item + '\n')

    i = 0
    last_abs_loc = [0, 0, 0, -1]
    RRAM_word = ''
    RRAM_word_list = []
    RRAM_word_list_full = []
    #make RRAM words
    while(i < len(weight_list_coded)):
        if(abs_loc_list[pe_id][i] != last_abs_loc and len(RRAM_word) == 0):
            RRAM_word = str(bindigits(abs_loc_list[pe_id][i][0], 9)) + str(bindigits(abs_loc_list[pe_id][i][1], 9)) + str(bindigits(abs_loc_list[pe_id][i][2], 4)) + str(bindigits(abs_loc_list[pe_id][i][3], 4)) + '1'
            last_abs_loc = abs_loc_list[pe_id][i]
        elif(abs_loc_list[pe_id][i] == last_abs_loc and len(RRAM_word) == 0):
            RRAM_word = '0'
        elif(abs_loc_list[pe_id][i] != last_abs_loc and len(RRAM_word) != 0):
            #print (RRAM_word)
            RRAM_word = '{message:>96{fill}}'.format(message=RRAM_word, fill='').replace(' ', '0')
            RRAM_word_list.append(RRAM_word)
            #print (RRAM_word + ' padded')
            RRAM_word = ''
        else:
            if(len(RRAM_word) + len(weight_list_coded[i]) + len(runlength_list_coded[i]) <= 96):
                RRAM_word = runlength_list_coded[i][::-1] + weight_list_coded[i][::-1] + RRAM_word
                last_abs_loc = abs_loc_list[pe_id][i]
                i = i + 1
                if(len(RRAM_word) == 96):
                    RRAM_word_list.append(RRAM_word)
                    RRAM_word = ''
                elif(i == len(weight_list_coded)):
                    RRAM_word = '{message:>96{fill}}'.format(message=RRAM_word, fill='').replace(' ', '0')
                    RRAM_word_list.append(RRAM_word)
                    RRAM_word = ''
            else:
                RRAM_word = (str(runlength_list_coded[i])[::-1] + str(weight_list_coded[i])[::-1])[len(str(weight_list_coded[i]) + str(runlength_list_coded[i]))-(96-len(RRAM_word)):] + RRAM_word
                RRAM_word_list.append(RRAM_word)
                RRAM_word = ''
        
    #RRAM_file = open('RRAM.txt', 'w+')
    for item in RRAM_word_list:
      RRAM_file[pe_id].write("%s\n" % item)
      RRAM_word_list_full.append( 'x'*64 + str(item[64:96]))
      RRAM_word_list_full.append( 'x'*64 + str(item[32:64]))
      RRAM_word_list_full.append( 'x'*64 + str(item[0:32]))

    for item in RRAM_word_list_full:
      RRAM_full_file[pe_id].write("%s\n" % item)
    
    #RRAM
    for i in range(0, len(RRAM_word_list_full)):
        rram_mem[pe_id][i%rram_banks].write(RRAM_word_list_full[i] + '\n') 
        rram_cnt[pe_id][i%rram_banks] = rram_cnt[pe_id][i%rram_banks] + 1
    
#fill rram
for pe_id in range(0, num_pe):
    for i in range(0, rram_banks):
        for rest_addr in range(0, 32768-rram_cnt[pe_id][i]):
            rram_mem[pe_id][i].write('x' * 96 + '\n')
for pe_id in range(0, num_pe):
    RRAM_file[pe_id].close()
    for i in range(0, rram_banks):
        rram_mem[pe_id][i].close()

#IA GLOBAL SRAM
ia_mem=[]
for i in range(0, 2):
    ia_mem.append([])
    for j in range(0, 4):
        ia_mem[i].append(open('ia_' + str(i) + '_' + str(j) + '.mem','w+'))

ia_mem_cnt=[]
for j in range(0, 4):
    ia_mem_cnt.append(0)

ia_word_total = ''
ia_word_cnt = 0

for total_ic_cnt in range(0, ic_total/pe_ic):
    for row in range (0, ia_size):
        for col in range (0, ia_size):
            for ic_cnt in range (0, pe_ic):
                ia_word_total = str(bindigits(ia[total_ic_cnt*pe_ic+ic_cnt][row][col], 8)) + str(ia_word_total)
                ia_word_cnt = ia_word_cnt + 1
                for j in range(0, 4):
                    if(ia_word_cnt == 16*(j+1)):
                        ia_mem[write_ia_num][j].write(ia_word_total + '\n')
                        ia_word_total = ''
                        ia_mem_cnt[j] = ia_mem_cnt[j] + 1
                        if(j == 3):
                            ia_word_cnt = 0

for j in range(0, 4):
    for rest_addr in range(0, 8192-ia_mem_cnt[j]):
        ia_mem[write_ia_num][j].write('0' * 128 + '\n')

for i in range(0, 2):
    for j in range(0, 4):
        for rest_addr in range(0, 8192):
            if(i != write_ia_num):
                ia_mem[i][j].write('0' * 128 + '\n')

for i in range(0, 2):
    for j in range(0, 4):
        ia_mem[i][j].close()

#OA SRAM
oa_mem=[]
for i in range(0, 2):
    oa_mem.append([])
    for j in range(0, 4):
        oa_mem[i].append(open('oa_' + str(i) + '_' + str(j) + '.mem','w+'))

oa_mem_cnt=[]
for j in range(0, 4):
    oa_mem_cnt.append(0)

oa_word_total = ''
oa_word_cnt = 0

for total_oc_cnt in range(0, oc_total/pe_oc):
    for row in range (0, oa_size):
        for col in range (0, oa_size):
            for oc_cnt in range (0, pe_oc):
                oa_word_total = str(bindigits(oa[total_oc_cnt*pe_oc+oc_cnt][row][col], 8)) + str(oa_word_total)
                #if(row >= 0 and row < 9 and col >=0 and col < 9):
                #if(row >= 0 and row < 9):
                #if(row >= 0 and row < 9 and col >=17 and col < 25):
                #    oa_word_total = str(bindigits(oa[total_oc_cnt*pe_oc+oc_cnt][row][col], 8)) + str(oa_word_total)
                #else:
                #    oa_word_total = '00000000' + str(oa_word_total)

                oa_word_cnt = oa_word_cnt + 1
                for j in range(0, 4):
                    if(oa_word_cnt == 16*(j+1)):
                        oa_mem[write_oa_num][j].write(oa_word_total + '\n')
                        oa_word_total = ''
                        oa_mem_cnt[j] = oa_mem_cnt[j] + 1
                        if(j == 3):
                            oa_word_cnt = 0

for j in range(0, 4):
    for rest_addr in range(0, 8192-oa_mem_cnt[j]):
        oa_mem[write_oa_num][j].write('0' * 128 + '\n')

for i in range(0, 2):
    for j in range(0, 4):
        for rest_addr in range(0, 8192):
            if(i != write_oa_num):
                oa_mem[i][j].write('0' * 128 + '\n')

for i in range(0, 2):
    for j in range(0, 4):
        oa_mem[i][j].close()


weight_golden = open('weight.txt','w+') 
for oc_cnt in range (0, oc_total):
    for ic_cnt in range (0, ic_total):
        weight_golden.write('w channel: [' + str(oc_cnt) + ', ' + str(ic_cnt) + ']\n')
        for row in range (0, kernel_size):
            for col in range (0, kernel_size):
                weight_golden.write(str(format(sparse_w[oc_cnt][ic_cnt][row][col], '4d')) + '\t')
            weight_golden.write('\n')

weight_golden.close()

ia_golden = open('ia.txt','w+') 
for ic_cnt in range (0, ic_total):
    ia_golden.write('ia channel: [' + str(ic_cnt) + ']\n')
    for row in range (0, ia_size):
        for col in range (0, ia_size):
            ia_golden.write(str(format(ia[ic_cnt][row][col], '4d')) + '\t')
        ia_golden.write('\n')

ia_golden.close()

oa_read_golden = open('oa_read.txt','w+') 
for oc_cnt in range (0, oc_total):
    oa_read_golden.write('oa channel: [' + str(oc_cnt) + ']\n')
    for row in range (0, oa_size - output_kernel_size + 1):
        for col in range (0, oa_size - output_kernel_size + 1):
            oa_read_golden.write(str(format(oa_read[oc_cnt][row][col], '4d')) + '\t')
        oa_read_golden.write('\n')

oa_read_golden.close()

oa_golden = open('oa.txt','w+') 
for oc_cnt in range (0, oc_total):
    oa_golden.write('oa channel: [' + str(oc_cnt) + ']\n')
    for row in range (0, oa_size):
        for col in range (0, oa_size):
            oa_golden.write(str(format(oa[oc_cnt][row][col], '4d')) + '\t')
        oa_golden.write('\n')

oa_golden.close()

oa_original_golden = open('oa_original.txt','w+') 
for oc_cnt in range (0, oc_total):
    oa_original_golden.write('oa channel: [' + str(oc_cnt) + ']\n')
    for row in range (0, oa_size):
        for col in range (0, oa_size):
            oa_original_golden.write(str(format(oa_original[oc_cnt][row][col], '4d')) + '\t')
        oa_original_golden.write('\n')

oa_original_golden.close()

oa_raw_golden = open('oa_raw.txt','w+') 
for oc_cnt in range (0, oc_total):
    oa_raw_golden.write('oa channel: [' + str(oc_cnt) + ']\n')
    for row in range (0, ia_size):
        for col in range (0, ia_size):
            oa_raw_golden.write(str(format(numpy.right_shift(oa_raw[oc_cnt][row][col], 0), '4d')) + '\t')
        oa_raw_golden.write('\n')

oa_raw_golden.close()

#print(weights)
#print('ia')
#print(ia)
#print('oa')
#print(oa)


